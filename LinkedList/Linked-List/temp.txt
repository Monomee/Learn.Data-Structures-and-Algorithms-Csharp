namespace MyLinkedList
{
    public class LinkedList<T>
    {
        private Node<T>? head;
        private Node<T>? tail;

        // Constructor initializing an empty linked list
        public LinkedList()
        {
            head = null;
            tail = null;
            count = 0;
        }

        private int count;

        // ========== Check ==========
        public bool IsEmpty()
        {
            return count == 0;
        }
        public int Count()
        {
            return count;
        }
        public bool Contains(T data)
        {
            if (IsEmpty())
            {
                return false;
            }
            Node<T> current = head;
            while (current != null)
            {
                if (EqualityComparer<T>.Default.Equals(data, current.Data))
                {
                    return true;
                }
                current = current.Next;
            }
            return false;
        }
        // ========== Add ==========
        public void AddLast(T data)
        {
            Node<T> newNode = new Node<T>(data);
            if (IsEmpty())
            {
                head = newNode;
                tail = newNode;
            }
            else
            {
                tail.Next = newNode;
                tail = newNode;
            }
            count++;
        }
        public void AddFirst(T data)
        {
            Node<T> newNode = new Node<T>(data);
            if (IsEmpty())
            {
                head = newNode;
                tail = newNode;
            }
            else
            {
                newNode.Next = head;
                head = newNode;
            }
            count++;
        }
        //public void AddAt(T data, int index)
        //{
        //    if (index < 0 || index  > count)
        //    {
        //        throw new Exception("Can not add at this index!");
        //    }
        //    if (index == 0)
        //    {
        //        AddFirst(data);
        //        return;
        //    }
        //    if (index == count)
        //    {
        //        AddLast(data);
        //        return;
        //    }

        //    Node<T> newNode = new Node<T>(data);
        //    Node<T> current = head;
        //    Node<T> previous = null;
        //    int i = 1;
        //    while (i < index)
        //    {
        //        previous = current;
        //        current = current.Next;
        //        i++;
        //    }
        //    previous.Next = newNode;
        //    newNode.Next = current;
        //    count++;
        //}
        public void AddAt(T data, int index)
        {
            if (index < 0 || index > count) throw new Exception("Index out of range!");

            if (index == 0) { AddFirst(data); return; }
            if (index == count) { AddLast(data); return; }

            Node<T> newNode = new Node<T>(data);
            Node<T> current = head;

            for (int k = 0; k < index - 1; k++)
            {
                current = current.Next;
            }

            newNode.Next = current.Next;
            current.Next = newNode;
            count++;
        }
        // ========== Remove ==========
        public void RemoveAll()
        {
            head = tail = null;
            count = 0;
        }
        public void RemoveLast()
        {
            if (IsEmpty())
            {
                throw new Exception("Can not remove an empty linked-list!");
            }
            if (head == tail)
            {
                head = tail = null;
                count--;
                return;
            }
            Node<T> current = head;
            Node<T> previous = null;
            while (current != tail)
            {
                previous = current;
                current = current.Next;
            }
            previous.Next = null;
            tail = previous;
            count--;
        }
        public void RemoveFirst()
        {
            if (IsEmpty())
            {
                throw new Exception("Can not remove an empty linked-list!");
            }
            head = head.Next;
            if (head == null)
            {
                tail = null;
            }
            count--;
        }
        //public void RemoveAt(int index)
        //{
        //    if (IsEmpty() || index < 0 || index > count)
        //    {
        //        throw new Exception("Can not remove at this index!");
        //    }
        //    if (index == 0)
        //    {
        //        RemoveFirst();
        //        return;
        //    }
        //    if (index == count - 1)
        //    {
        //        RemoveLast();
        //        return;
        //    }
        //    Node<T> previous = head;
        //    int i = 0;
        //    while (i < index - 1)
        //    {
        //        previous = previous.Next;
        //        i++;
        //    }
        //    previous.Next = previous.Next.Next;
        //    count--;
        //}
        public void RemoveAt(int index)
        {
            if (IsEmpty() || index < 0 || index >= count)
            {
                throw new Exception("Can not remove at this index!");
            }

            if (index == 0) { RemoveFirst(); return; }
            if (index == count - 1) { RemoveLast(); return; } // RemoveLast đã xử lý cập nhật tail

            Node<T> previous = head;
            // Dùng vòng for dễ kiểm soát hơn while trong trường hợp này
            for (int k = 0; k < index - 1; k++)
            {
                previous = previous.Next;
            }

            // Xóa node
            previous.Next = previous.Next.Next;
            count--;
        }
        //public void RemoveAll(T data)
        //{
        //    Node<T> current = head;
        //    Node<T> previous = null;

        //    while (current != null)
        //    {
        //        if (EqualityComparer<T>.Default.Equals(data, current.Data))
        //        {
        //            if (current == head)
        //            {
        //                head = head.Next;
        //                current = head;
        //                if (head == null) tail = null;
        //                count--;
        //            }
        //            else
        //            {
        //                previous.Next = current.Next;
        //                if (current == tail)
        //                    tail = previous;

        //                current = previous.Next;
        //                count--;
        //            }
        //        }
        //        else
        //        {
        //            previous = current;
        //            current = current.Next;
        //        }
        //    }
        //}
        public void RemoveAll(T data)
        {
            if (IsEmpty()) return;

            // Tạo node ảo để xử lý trường hợp node cần xóa nằm ở Head dễ dàng hơn
            Node<T> dummy = new Node<T>(default(T));
            dummy.Next = head;

            Node<T> previous = dummy;
            Node<T> current = head;
            EqualityComparer<T> comparer = EqualityComparer<T>.Default;

            while (current != null)
            {
                if (comparer.Equals(data, current.Data))
                {
                    // Tìm thấy: Bỏ qua current, nối previous với next của current
                    previous.Next = current.Next;

                    // Nếu xóa trúng đuôi, cập nhật lại tail
                    if (current == tail)
                    {
                        tail = previous == dummy ? null : previous;
                    }

                    count--;
                    // Không cập nhật previous, chỉ cập nhật current để tiếp tục xét node tiếp theo
                    current = current.Next;
                }
                else
                {
                    // Không trùng: Cả 2 cùng tiến lên
                    previous = current;
                    current = current.Next;
                }
            }

            // Cập nhật lại head thật sự từ dummy
            head = dummy.Next;
            // Nếu danh sách rỗng sau khi xóa hết
            if (head == null) tail = null;
        }
        public void RemoveFirst(T data)
        {
            if (IsEmpty())
                throw new Exception("Can not remove an empty linked-list!");

            Node<T> current = head;
            Node<T> previous = null;

            while (current != null)
            {
                if (EqualityComparer<T>.Default.Equals(data, current.Data))
                {
                    // Case 1: xoá head
                    if (current == head)
                    {
                        head = head.Next;
                        if (head == null)
                            tail = null;

                        count--;
                        return;
                    }

                    // Case 2: xoá node giữa/cuối
                    previous.Next = current.Next;

                    if (current == tail)
                        tail = previous;

                    count--;
                    return;
                }

                previous = current;
                current = current.Next;
            }
        }
        // ========== Traverse ==========
        public Node<T> Get(int index)
        {
            if (index < 0 || index + 1 > count)
            {
                throw new Exception("Can not get at this index!");
            }
            Node<T> current = head;
            int i = 0;
            while (i < index)
            {
                current = current.Next;
                i++;
            }
            return current;
        }
        //public void Traverse()
        //{
        //    Node<T>? current = head;
        //    while (current != null)
        //    {
        //        current = current.Next;
        //    }
        //}
        public void Display()
        {
            Console.WriteLine("Linked-list:");
            Node<T>? current = head;
            int index = 0;
            while (current != null)
            {
                Console.WriteLine($"{index}. {current.Data}");
                current = current.Next;
                index++;
            }
        }
    }
}
